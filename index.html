<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Clash of Cubes â€“ Team Flip & Runner Bonus</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(255,255,255,0.9);
      padding: 10px;
      font-family: Arial, sans-serif;
    }
    #countdown, #endMessage, #bonusMessage {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      font-size: 64px;
      z-index: 9;
      display: none;
    }
    #countdown { top: 50%; color: white; }
    #endMessage { top: 40%; color: white; }
    #bonusMessage {
      top: 70%;
      color: yellow;
      font-size: 48px;
    }
    #scoreboard, #restartStatus {
      margin-top: 10px;
      font-size: 14px;
    }
  </style>
  <!-- Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- PeerJS -->
  <script src="https://cdn.jsdelivr.net/npm/peerjs@1.4.7/dist/peerjs.min.js"></script>
</head>
<body>
  <div id="info">
    <div>Your Peer ID: <span id="my-id">Loading...</span></div>
    <input type="text" id="peer-id-input" placeholder="Enter peer ID to connect">
    <button id="connect-btn">Connect</button>
    <br><br>
    <input type="text" id="username-input" placeholder="Enter username">
    <button id="set-username-btn">Set Username</button>
    <p id="roleInfo"></p>
    <div id="scoreboard"></div>
    <div id="restartStatus"></div>
    <p>Use WASD to move (wait for connection). Press Space to jump.<br>
       When TAGGED press R to request a restart.</p>
  </div>
  <div id="countdown">3</div>
  <div id="endMessage"></div>
  <div id="bonusMessage">BONUS!</div>
  <script>
    // ==========================
    // GLOBAL SETTINGS & VARIABLES
    // ==========================
    let gameStarted = false;
    let gameEnded = false;
    let countdownTime = 3;
    const playerRadius = 1;
    const treeCollisionRadius = 2;
    const gravity = -30;
    const jumpForce = 15;
    const accelerationVal = 30;
    const turnSpeed = 3;
    const frictionVal = 10;
    const maxSpeed = 20;
    let playerSpeed = 0;
    
    // For runner bonus mechanic.
    let runnerBonusTimer = 0; // accumulates time if runner is moving fast

    // Restart handshake flags (both must be true)
    let localReplay = false;
    let remoteReplay = false;
    
    // Team and username variables
    let localTeam = null;   // "red" (tagger) or "blue" (runner)
    let remoteTeam = null;
    let teamAssigned = false; // set once on connection
    let localUsername = "Player";
    let remoteUsername = "Opponent";
    let redScore = 0;
    let blueScore = 0;
    
    // Player references, nametags.
    let localPlayer, remotePlayer;
    let localNameTag, remoteNameTag;
    
    // ==========================
    // UTILITIES & TERRAIN
    // ==========================
    function createSeededRandom(seed) {
      let s = seed;
      return function() {
        s = (s * 9301 + 49297) % 233280;
        return s / 233280;
      };
    }
    const random = createSeededRandom(123456);
    
    // Create scene, camera, renderer.
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb);
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);
    
    // Lighting.
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(20,50,10);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 1024;
    directionalLight.shadow.mapSize.height = 1024;
    directionalLight.shadow.camera.near = 0.5;
    directionalLight.shadow.camera.far = 500;
    directionalLight.shadow.camera.left = -100;
    directionalLight.shadow.camera.right = 100;
    directionalLight.shadow.camera.top = 100;
    directionalLight.shadow.camera.bottom = -100;
    scene.add(directionalLight);
    
    // Terrain: Hilly ground.
    function getGroundHeightAt(x, z) {
      const frequency = 0.1;
      const amplitude = 3;
      return Math.sin(x * frequency) * Math.cos(z * frequency) * amplitude;
    }
    const segments = 100;
    const groundGeometry = new THREE.PlaneGeometry(200,200,segments,segments);
    groundGeometry.rotateX(-Math.PI/2);
    for(let i=0; i<groundGeometry.attributes.position.count; i++){
      let x = groundGeometry.attributes.position.getX(i);
      let z = groundGeometry.attributes.position.getZ(i);
      let y = getGroundHeightAt(x,z);
      groundGeometry.attributes.position.setY(i,y);
    }
    groundGeometry.computeVertexNormals();
    const groundMaterial = new THREE.MeshLambertMaterial({color: 0x228B22});
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.receiveShadow = true;
    ground.castShadow = true;
    scene.add(ground);
    
    // ==========================
    // PLAYER CUBES & NAMETAGS
    // ==========================
    function createCharacterCube(baseColor, options = {}) {
      const size = 2;
      const canvas = document.createElement("canvas");
      canvas.width = 128;
      canvas.height = 128;
      const ctx = canvas.getContext("2d");
      ctx.fillStyle = '#' + baseColor.toString(16).padStart(6, '0');
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = "white";
      ctx.beginPath();
      ctx.arc(40,50,12,0,Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(88,50,12,0,Math.PI*2);
      ctx.fill();
      const leftPupilOffsetX = options.leftEye?.pupilOffsetX || 0;
      const leftPupilOffsetY = options.leftEye?.pupilOffsetY || 0;
      const rightPupilOffsetX = options.rightEye?.pupilOffsetX || 0;
      const rightPupilOffsetY = options.rightEye?.pupilOffsetY || 0;
      ctx.fillStyle = "black";
      ctx.beginPath();
      ctx.arc(40+leftPupilOffsetX,50+leftPupilOffsetY,5,0,Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(88+rightPupilOffsetX,50+rightPupilOffsetY,5,0,Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = "black";
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.arc(64,85,20,0,Math.PI);
      ctx.stroke();
      const faceTexture = new THREE.CanvasTexture(canvas);
      faceTexture.needsUpdate = true;
      const materials = [
        new THREE.MeshLambertMaterial({color: baseColor}),
        new THREE.MeshLambertMaterial({color: baseColor}),
        new THREE.MeshLambertMaterial({color: baseColor}),
        new THREE.MeshLambertMaterial({color: baseColor}),
        new THREE.MeshLambertMaterial({map: faceTexture}),
        new THREE.MeshLambertMaterial({color: baseColor})
      ];
      const geometry = new THREE.BoxGeometry(size,size,size);
      const cube = new THREE.Mesh(geometry, materials);
      cube.castShadow = true;
      cube.receiveShadow = true;
      cube.velocity = new THREE.Vector3(0,0,0);
      cube.canDoubleJump = false;
      return cube;
    }
    
    // Random spawn.
    function randomSpawn() {
      const centerX = Math.random() * 180 - 90;
      const centerZ = Math.random() * 180 - 90;
      const separation = 10;
      const angle = Math.random() * 2 * Math.PI;
      const dx = Math.cos(angle) * separation/2;
      const dz = Math.sin(angle) * separation/2;
      blueCube.position.set(centerX + dx, getGroundHeightAt(centerX + dx, centerZ + dz) + 1, centerZ + dz);
      redCube.position.set(centerX - dx, getGroundHeightAt(centerX - dx, centerZ - dz) + 1, centerZ - dz);
      const spawnAngle = Math.atan2((redCube.position.z - blueCube.position.z), (redCube.position.x - blueCube.position.x));
      blueCube.rotation.y = spawnAngle + Math.PI;
      redCube.rotation.y = spawnAngle;
      blueCube.velocity.set(0,0,0);
      redCube.velocity.set(0,0,0);
    }
    
    const blueCube = createCharacterCube(0x0000ff, {
      leftEye: { pupilOffsetX: 2, pupilOffsetY: 2 },
      rightEye: { pupilOffsetX: -2, pupilOffsetY: 2 }
    });
    const redCube = createCharacterCube(0xff0000, {
      leftEye: { pupilOffsetX: -2, pupilOffsetY: 2 },
      rightEye: { pupilOffsetX: 2, pupilOffsetY: 2 }
    });
    randomSpawn();
    scene.add(blueCube);
    scene.add(redCube);
    // Initially assign local and remote (will be updated upon connection).
    localPlayer = blueCube;
    remotePlayer = redCube;
    
    // Create and attach nametags.
    function createNameTag(text) {
      const canvas = document.createElement("canvas");
      canvas.width = 256;
      canvas.height = 64;
      const ctx = canvas.getContext("2d");
      ctx.font = "28px Arial";
      ctx.fillStyle = "white";
      ctx.textAlign = "center";
      ctx.fillText(text, canvas.width/2, canvas.height/2 + 10);
      const texture = new THREE.CanvasTexture(canvas);
      const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
      const sprite = new THREE.Sprite(material);
      sprite.scale.set(4,1,1);
      return sprite;
    }
    function updateNameTag(sprite, text) {
      const canvas = document.createElement("canvas");
      canvas.width = 256;
      canvas.height = 64;
      const ctx = canvas.getContext("2d");
      ctx.font = "28px Arial";
      ctx.fillStyle = "white";
      ctx.textAlign = "center";
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.fillText(text, canvas.width/2, canvas.height/2 + 10);
      sprite.material.map.image = canvas;
      sprite.material.map.needsUpdate = true;
    }
    localNameTag = createNameTag(localUsername);
    localNameTag.position.set(0, 2.5, 0);
    localPlayer.add(localNameTag);
    remoteNameTag = createNameTag(remoteUsername);
    remoteNameTag.position.set(0, 2.5, 0);
    remotePlayer.add(remoteNameTag);
    
    // ==========================
    // STATIC OBJECTS: TREES & PARKOUR
    // ==========================
    const trees = [];
    function createTree(x, z) {
      const tree = new THREE.Group();
      const trunkGeometry = new THREE.CylinderGeometry(0.3,0.3,3,6);
      const trunkMaterial = new THREE.MeshLambertMaterial({color: 0x8B4513});
      const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
      trunk.position.y = 1.5;
      trunk.castShadow = true;
      tree.add(trunk);
      const leavesGeometry = new THREE.ConeGeometry(1.5,4,6);
      const leavesMaterial = new THREE.MeshLambertMaterial({color: 0x228B22});
      const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
      leaves.position.y = 4.5;
      leaves.castShadow = true;
      tree.add(leaves);
      tree.position.set(x, getGroundHeightAt(x,z), z);
      return tree;
    }
    for(let i=0;i<50;i++){
      const x = random()*180 - 90;
      const z = random()*180 - 90;
      if(Math.abs(x)<20 && Math.abs(z)<20){ i--; continue; }
      const tree = createTree(x,z);
      trees.push(tree);
      scene.add(tree);
    }
    
    const parkourPlatforms = [];
    function createPlatform(x, y, z, width, height, depth, color=0x888888) {
      const geometry = new THREE.BoxGeometry(width,height,depth);
      const material = new THREE.MeshLambertMaterial({color});
      const platform = new THREE.Mesh(geometry, material);
      platform.castShadow = true;
      platform.receiveShadow = true;
      platform.position.set(x, y - height/2, z);
      scene.add(platform);
      parkourPlatforms.push(platform);
    }
    function createSpiralParkourCourse() {
      const numPlatforms = 30;
      const baseX = 20, baseZ = 0, baseY = getGroundHeightAt(20,0)+3;
      const spiralRadius = 10;
      const angleIncrement = Math.PI/6;
      const heightIncrement = 2;
      for(let i=0;i<numPlatforms;i++){
        const angle = i*angleIncrement;
        const x = baseX + spiralRadius*Math.cos(angle);
        const z = baseZ + spiralRadius*Math.sin(angle);
        const y = baseY + i*heightIncrement;
        createPlatform(x,y,z,2.5,0.8,2.5,0xcccccc);
      }
      const finalAngle = numPlatforms*angleIncrement;
      const finalX = baseX + spiralRadius*Math.cos(finalAngle);
      const finalZ = baseZ + spiralRadius*Math.sin(finalAngle);
      const finalY = baseY + numPlatforms*heightIncrement;
      createPlatform(finalX, finalY, finalZ,4,1,4,0xffd700);
    }
    createSpiralParkourCourse();
    
    // ==========================
    // SCOREBOARD UPDATE
    // ==========================
    function updateScoreboard() {
      document.getElementById('scoreboard').innerHTML = 
        `<strong>Red (TAGGER):</strong> ${ (localTeam==="red" ? localUsername : remoteUsername) } - ${redScore} &nbsp;&nbsp; ` +
        `<strong>Blue (RUNNER):</strong> ${ (localTeam==="blue" ? localUsername : remoteUsername) } - ${blueScore}`;
    }
    updateScoreboard();
    
    // ==========================
    // BONUS MESSAGE
    // ==========================
    function showBonusMessage(){
      const bonusDiv = document.getElementById('bonusMessage');
      bonusDiv.style.display = 'block';
      setTimeout(() => { bonusDiv.style.display = 'none'; }, 1000);
    }
    
    // ==========================
    // PEER MESSAGING SETUP
    // ==========================
    function sendMessage(message) {
      if(conn && conn.open) {
        conn.send(message);
      }
    }
    
    // ==========================
    // PEERJS SETUP, TEAM & USERNAME ASSIGNMENT
    // ==========================
    let conn;
    const peer = new Peer(undefined, {host:'0.peerjs.com', secure:true, port:443});
    peer.on('open', (id)=>{
      document.getElementById('my-id').textContent = id;
    });
    peer.on('error', (err)=>{ console.error("Peer error:", err); });
    
    // Unified data handler.
    function handleData(data) {
      if(data.type) {
        switch(data.type) {
          case "teamAssignment":
            if(!teamAssigned) {
              // Senderâ€™s team; assign the opposite.
              if(data.team === "red") {
                localTeam = "blue"; remoteTeam = "red";
                localPlayer = blueCube; remotePlayer = redCube;
              } else {
                localTeam = "red"; remoteTeam = "blue";
                localPlayer = redCube; remotePlayer = blueCube;
              }
              teamAssigned = true;
              document.getElementById('roleInfo').textContent = "You are " + (localTeam==="red" ? "TAGGER (Red)" : "RUNNER (Blue)");
              sendMessage({ type: "teamAssignment", team: localTeam });
              startCountdown();
            }
            break;
          case "username":
            // Always update remote username.
            remoteUsername = data.username || "Opponent";
            updateNameTag(remoteNameTag, remoteUsername);
            updateScoreboard();
            break;
          case "movement":
            remotePlayer.position.set(data.x, data.y, data.z);
            remotePlayer.rotation.y = data.rotation;
            break;
          case "tag":
            triggerTag();
            break;
          case "restart":
            remoteReplay = true;
            document.getElementById('restartStatus').textContent = "Opponent pressed restart.";
            checkReplay();
            break;
          case "resume":
            restartGame();
            break;
        }
      }
    }
    
    peer.on('connection', (connection)=>{
      conn = connection;
      conn.on('data', handleData);
      // Always send the username on connection.
      sendMessage({ type: "username", username: localUsername });
      if(teamAssigned) {
        sendMessage({ type: "teamAssignment", team: localTeam });
      }
    });
    
    document.getElementById('connect-btn').addEventListener('click', ()=>{
      const peerId = document.getElementById('peer-id-input').value;
      if(!peerId)return;
      conn = peer.connect(peerId);
      conn.on('open', ()=>{
        conn.on('data', handleData);
        if(!teamAssigned) {
          // Randomly assign team for initiator.
          if(Math.random() < 0.5) {
            localTeam = "red"; remoteTeam = "blue";
            localPlayer = redCube; remotePlayer = blueCube;
          } else {
            localTeam = "blue"; remoteTeam = "red";
            localPlayer = blueCube; remotePlayer = redCube;
          }
          teamAssigned = true;
          document.getElementById('roleInfo').textContent = "You are " + (localTeam==="red" ? "TAGGER (Red)" : "RUNNER (Blue)");
          sendMessage({ type: "teamAssignment", team: localTeam });
          sendMessage({ type: "username", username: localUsername });
          startCountdown();
          updateScoreboard();
        }
      });
      conn.on('error', (err)=>{ console.error("Connection error:", err); });
    });
    
    document.getElementById('set-username-btn').addEventListener('click', ()=>{
      const uname = document.getElementById('username-input').value.trim();
      if(uname!==""){
        localUsername = uname;
        updateNameTag(localNameTag, localUsername);
        updateScoreboard();
        // Always send username update.
        sendMessage({ type: "username", username: localUsername });
      }
    });
    
    // ==========================
    // INPUT HANDLING
    // ==========================
    const keys = {w:false,a:false,s:false,d:false,' ':false};
    document.addEventListener('keydown', (e)=>{
      const key = e.key.toLowerCase();
      if(key in keys){
        if(key===' ' && !keys[' ']){
          if(isPlayerGrounded()){
            localPlayer.velocity.y = jumpForce;
            localPlayer.canDoubleJump = true;
          } else if(localPlayer.canDoubleJump){
            localPlayer.velocity.y = jumpForce * 0.8;
            localPlayer.velocity.x += Math.sin(localPlayer.rotation.y)*5;
            localPlayer.velocity.z += Math.cos(localPlayer.rotation.y)*5;
            localPlayer.canDoubleJump = false;
          }
        }
        keys[key] = true;
      }
      // Restart key â€“ both must press R.
      if(gameEnded && key==='r'){
        localReplay = true;
        document.getElementById('restartStatus').textContent = "You pressed restart. Waiting for opponent...";
        sendMessage({ type: "restart" });
        checkReplay();
      }
    });
    document.addEventListener('keyup', (e)=>{
      const key = e.key.toLowerCase();
      if(key in keys) keys[key] = false;
    });
    
    function isPlayerGrounded(){
      const groundY = getGroundHeightAt(localPlayer.position.x, localPlayer.position.z)+1;
      if(Math.abs(localPlayer.position.y - groundY) < 0.15 && localPlayer.velocity.y <= 0) return true;
      for(let platform of parkourPlatforms){
        const platformBox = new THREE.Box3().setFromObject(platform);
        if(Math.abs((localPlayer.position.y - 1) - platformBox.max.y) < 0.15 && localPlayer.velocity.y <= 0)
          return true;
      }
      return false;
    }
    
    // ==========================
    // TAG LOGIC
    // ==========================
    function checkForTag(){
      if(localTeam==="red" && !gameEnded){
        const localBox = new THREE.Box3().setFromObject(localPlayer);
        const remoteBox = new THREE.Box3().setFromObject(remotePlayer);
        if(localBox.intersectsBox(remoteBox)){
          sendMessage({ type: "tag" });
          triggerTag();
        }
      }
    }
    function triggerTag(){
      if(gameEnded)return;
      gameEnded = true;
      redScore++;
      updateScoreboard();
      document.getElementById('endMessage').textContent = "TAG! Press R to restart if you agree.";
      document.getElementById('endMessage').style.display = 'block';
    }
    
    // ==========================
    // RESTART LOGIC & TEAM FLIP
    // ==========================
    function checkReplay(){
      if(localReplay && remoteReplay){
        sendMessage({ type: "resume" });
        restartGame();
      }
    }
    function restartGame(){
      localReplay = false;
      remoteReplay = false;
      gameEnded = false;
      gameStarted = false;
      document.getElementById('endMessage').style.display = 'none';
      document.getElementById('restartStatus').textContent = "";
      
      // Flip teams.
      if(localTeam === "red"){
        localTeam = "blue"; remoteTeam = "red";
        localPlayer = blueCube; remotePlayer = redCube;
      } else {
        localTeam = "red"; remoteTeam = "blue";
        localPlayer = redCube; remotePlayer = blueCube;
      }
      document.getElementById('roleInfo').textContent = "You are " + (localTeam==="red" ? "TAGGER (Red)" : "RUNNER (Blue)");
      
      // Reset positions.
      const centerX = Math.random()*180 - 90;
      const centerZ = Math.random()*180 - 90;
      const separation = 10;
      const angle = Math.random()*2*Math.PI;
      const dx = Math.cos(angle) * separation/2;
      const dz = Math.sin(angle) * separation/2;
      blueCube.position.set(centerX + dx, getGroundHeightAt(centerX + dx, centerZ + dz)+1, centerZ + dz);
      redCube.position.set(centerX - dx, getGroundHeightAt(centerX - dx, centerZ - dz)+1, centerZ - dz);
      const spawnAngle = Math.atan2((redCube.position.z - blueCube.position.z), (redCube.position.x - blueCube.position.x));
      blueCube.rotation.y = spawnAngle + Math.PI;
      redCube.rotation.y = spawnAngle;
      blueCube.velocity.set(0,0,0);
      redCube.velocity.set(0,0,0);
      
      // Reset runner bonus timer.
      runnerBonusTimer = 0;
      startCountdown();
    }
    
    // ==========================
    // COUNTDOWN
    // ==========================
    const countdownDiv = document.getElementById('countdown');
    function startCountdown(){
      if(gameStarted)return;
      countdownDiv.style.display = 'block';
      countdownTime = 3;
      countdownDiv.textContent = countdownTime;
      const countdownInterval = setInterval(()=>{
        countdownTime--;
        if(countdownTime<=0){
          clearInterval(countdownInterval);
          countdownDiv.style.display = 'none';
          gameStarted = true;
        } else {
          countdownDiv.textContent = countdownTime;
        }
      },1000);
    }
    
    // ==========================
    // COLLISION DETECTION & MOVEMENT
    // ==========================
    function checkCollision(newPos){
      const dx = newPos.x - remotePlayer.position.x;
      const dz = newPos.z - remotePlayer.position.z;
      if(Math.hypot(dx,dz) < (playerRadius*2)) return true;
      for(let tree of trees){
        const tx = tree.position.x;
        const tz = tree.position.z;
        if(Math.hypot(newPos.x-tx, newPos.z-tz) < (playerRadius+treeCollisionRadius))
          return true;
      }
      const playerBox = new THREE.Box3().setFromCenterAndSize(
        new THREE.Vector3(newPos.x, localPlayer.position.y, newPos.z),
        new THREE.Vector3(1.5,2,1.5)
      );
      for(let platform of parkourPlatforms){
        const platformBox = new THREE.Box3().setFromObject(platform);
        const feetY = localPlayer.position.y - 1;
        if(Math.abs(feetY - platformBox.max.y)<0.3) continue;
        if(playerBox.intersectsBox(platformBox)) return true;
      }
      return false;
    }
    
    const cameraDistance = 15;
    const cameraHeight = 10;
    let lastTime = performance.now();
    function animate(){
      requestAnimationFrame(animate);
      const currentTime = performance.now();
      const delta = Math.min((currentTime-lastTime)/1000, 0.1);
      lastTime = currentTime;
      if(gameStarted && !gameEnded){
        if(keys.a) localPlayer.rotation.y += turnSpeed * delta;
        if(keys.d) localPlayer.rotation.y -= turnSpeed * delta;
        let forwardAcceleration = 0;
        if(keys.w) forwardAcceleration = accelerationVal;
        else if(keys.s) forwardAcceleration = -accelerationVal;
        playerSpeed += forwardAcceleration * delta;
        if(!keys.w && !keys.s){
          if(playerSpeed>0) playerSpeed = Math.max(playerSpeed-frictionVal*delta,0);
          else if(playerSpeed<0) playerSpeed = Math.min(playerSpeed+frictionVal*delta,0);
        }
        playerSpeed = THREE.MathUtils.clamp(playerSpeed, -maxSpeed, maxSpeed);
        localPlayer.velocity.x = Math.sin(localPlayer.rotation.y) * playerSpeed;
        localPlayer.velocity.z = Math.cos(localPlayer.rotation.y) * playerSpeed;
        localPlayer.velocity.y += gravity * delta;
        localPlayer.position.y += localPlayer.velocity.y * delta;
        const groundY = getGroundHeightAt(localPlayer.position.x, localPlayer.position.z)+1;
        if(localPlayer.position.y < groundY){
          localPlayer.position.y = groundY;
          localPlayer.velocity.y = 0;
          localPlayer.canDoubleJump = true;
        }
        (function handlePlatformCollisions(player){
          const playerBox = new THREE.Box3().setFromCenterAndSize(
            new THREE.Vector3(player.position.x, player.position.y-0.5, player.position.z),
            new THREE.Vector3(1.5,2,1.5)
          );
          for(let platform of parkourPlatforms){
            const platformBox = new THREE.Box3().setFromObject(platform);
            if(playerBox.intersectsBox(platformBox) && player.velocity.y<=0){
              const platformTopY = platformBox.max.y;
              const feetY = player.position.y-1;
              if(feetY>=platformTopY-0.3 && feetY<=platformTopY+0.5){
                player.position.y = platformTopY+1;
                player.velocity.y = 0;
                localPlayer.canDoubleJump = true;
              }
            }
          }
        })(localPlayer);
        const potentialPos = localPlayer.position.clone();
        potentialPos.x += localPlayer.velocity.x * delta;
        potentialPos.z += localPlayer.velocity.z * delta;
        potentialPos.x = THREE.MathUtils.clamp(potentialPos.x, -100, 100);
        potentialPos.z = THREE.MathUtils.clamp(potentialPos.z, -100, 100);
        if(!checkCollision(potentialPos)){
          localPlayer.position.x = potentialPos.x;
          localPlayer.position.z = potentialPos.z;
        } else {
          playerSpeed = 0;
          localPlayer.velocity.x = 0;
          localPlayer.velocity.z = 0;
        }
        // Runner bonus mechanic: only if you're the runner (blue) and moving fast.
        if(localTeam === "blue") {
          if(Math.abs(playerSpeed) >= 10) {
            runnerBonusTimer += delta;
            if(runnerBonusTimer >= 3) {
              blueScore++;
              updateScoreboard();
              showBonusMessage();
              runnerBonusTimer = 0;
            }
          } else {
            runnerBonusTimer = 0;
          }
        }
        // Send movement update.
        sendMessage({
          type: "movement",
          x: localPlayer.position.x,
          y: localPlayer.position.y,
          z: localPlayer.position.z,
          rotation: localPlayer.rotation.y
        });
        checkForTag();
      }
      // Camera follow.
      const forward = new THREE.Vector3(Math.sin(localPlayer.rotation.y), 0, Math.cos(localPlayer.rotation.y));
      const desiredCamPos = localPlayer.position.clone().sub(forward.multiplyScalar(cameraDistance)).add(new THREE.Vector3(0,cameraHeight,0));
      camera.position.lerp(desiredCamPos,0.1);
      camera.lookAt(localPlayer.position);
      renderer.render(scene, camera);
    }
    animate();
    
    // ==========================
    // WINDOW RESIZE
    // ==========================
    window.addEventListener('resize', ()=>{
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
